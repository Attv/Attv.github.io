---
layout:     post
title:      JVM初探
subtitle:   jvm
date:       2019-08-30
author:     路过
header-img: img/promo-bg.jpg
catalog: true
tags:
    - JVM
    - 虚拟机
    - java调优
---

### 1.什么是jvm?

> jvm实际上是将我们所写的java代码编译成.class文件最后通过执行引擎将编译后的.class文件加载到内存中，并启动一个可执行进程的一套机制，我们称之为java虚拟机

**这里只是简单的介绍了下jvm的概念，实际上里面还有类加载机制，垃圾回收机制，内存管理等等的部分,后面会讲.**



### 2.jvm是如何加载一个类的，这个过程是怎样的？

> 类加载的过程是一个相对比较复杂的过程，但是大致会经历以下几个过程：

---
`加载-> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载`

---
*那么jvm是什么时候进行这些操作的呢？*

**简单的回答就是当你的代码中使用到这些类的时候会进行加载，如果深入一点说的话，代码中这些类又分为主动加载和被动加载，而主动加载和被动加载又会导致这个过程中的某些环节是否会完全进行，关于主动加载被动加载这个问题，我们稍后再具体分析。**

* `加载`  这个动作比较好理解，这里就是将已经编译好的.class文件加载到内存当中
* `验证`  验证实际上就是判断被加载进来的.class文件是否合法，防止被篡改，比如开头是否是cafebabe这种字符串开头或者后面跟的版本好是否合法，这里属于字节码的那部分内容，后面会有专门的篇章来讲解。
* `准备`  准备阶段就是在加载的时候将我们定义的类分配一定的空间，并赋一个初始值。
* `解析`  这个阶段就是将我们定义好的类变量由符号引用改为直接引用
    - <u>*对于非接口的符号引用(假设符号引用指向类C)*</u>
        1. 在C中进行查找符合名字以及描述符的方法
        2. 如果没有找到的话，在C中继续像上找直至找到Object方法
        3. 如果还没有找到的话，在C所直接实现的接口中进行搜索，这一步搜索到的目标的方法必须是非私有、非静态的，并且如果目标方法在间接的实现类中，则需要满足C与该接口之间没有其他符合条件的方法，如果有返回任意一个。
    - <u>*对于接口的符号引用(假定该符号引用指向接口为I)*</u>
        1. 在I中查找符合名字以及描述的方法。
        2. 如果没找到的话，在Object共有类中进行查找搜索
        3. 如果还没找到的话，则在I的超接口中进行搜索，搜索结果与非接口的3步骤结果一致
* `初始化` 这里会将之前已经分配过内存空间的类变量赋一个正确的值

> 那么什么时候会初始化一个类呢？

* 当有`new`这个关键字去修饰一个对象的时候，会初始化一个类对象
* 当作为一个主类（包含main方法的类）的时候会初始化
* class.forName的时候会初始化
* 其他对象调用这个类里的方法的时候（静态）
...

### 3.类加载器以及双亲委派机制

> 类加载器又是做什么的呢？

**实际上类加载的主要过程都是通过类加载器来完成的。**

---
> jvm中类加载器包含以下几种：

| 加载器名称 |作用 | 加载范围 | 
|--- |:---:|:-------:|
|启动类加载器(Bootstrap classloader)|加载机器中安装的java目录下的核心类|lib目录下的文件|
|扩展类加载器(Extension ClassLoader)|同上|加载lib/ext路径下的类文件|
|应用程序加载器(Application ClassLoader)|加载classpath环境变量所指定的路径中的类|加载本地java文件|
|自定义类加载器|根据自身需求定义|根据自身需求定义|

> 加载顺序如下

![classloader](https://s2.ax1x.com/2019/08/30/mXG4vF.png)

### 4.双亲委派机制

如果需要jvm取加载一个类对象的时候,首先会找到当前类加载器的父对象去加载，如果可以加载则继续向上传递直到不能加载为止，则由最后一个可以加载的父类进行加载。

> 为什么需要双亲委派机制

这是jvm为了保证类加载安全的一种机制，防止恶意篡改基础类文件导致出现问题。

![classloader](https://s2.ax1x.com/2019/08/30/mXg4BR.png)